<!DOCTYPE html>
<html>
<!-- base.html -->
<head>
    <title>japan.xlsx Holiday</title>
    <meta name="viewport" content="initial-scale=1.0">
    <meta charset="utf-8">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200" />
    <style>
        /* geodesix.css */
body {
    margin: 0 0 0 0;
}

html, body {
    padding: 0;
    font: 11pt Arial, sans-serif
}

table {
    border-collapse: collapse;
}

td {
    padding: 2px 4px 2px 3px
}

th {
    font-weight: bold;
}
/* .classes */
.center {
    text-align: center;
    vertical-align: middle;
}
.gm-style .gm-style-iw {
    /* infowindow */
    background-color: lightgoldenrodyellow;
}

.info {
    font: 9pt sans-serif;
    color: #333333;
    cursor: pointer;
    background-color: lightgoldenrodyellow;
    text-align: center;
    font-size: 11pt;
}

.key {
    text-align: right;
    font-weight: bold;
    vertical-align: top;
    white-space: nowrap
}

.popup {
    background-color: #FFFDD0;
    border: 1px solid #333333;
    border-radius: 3px;
    box-shadow: rgba(0, 0, 0, 0.1) 3px 3px;
    font: 11pt Arial, sans-serif;
    display: block;
    padding: 3px;
    position: relative;
    left: 30px;
    top: 30px;
    transition: opacity 1s;
    width: fit-content;
    opacity: 1;
}

    .popup.fade-out {
        opacity: 0;
    }

.tabContent {
    font: 10pt sans-serif;
    border-collapse: collapse;
    table-layout: auto;
}

.value {
    vertical-align: top;
}
/* .ids */
#map {
    width: 100%;
    height: 100%;
    border: 0;
    position: absolute;
}

#matches {
    display: none;
    font: 9pt sans-serif;
    position: absolute;
    background-color: #ffc995;
    border: 1px solid #8e8378;
    top: 5px;
    left: 5px;
    padding: 3px 3px 3px 3px;
}

#top {
    scroll-margin-top: -100px;
}
/* end geodesix.css */
        /* goverlay.css */
.goarrow {
    position: absolute;
    font-family: 'Material Symbols Outlined';
}

.gobox {
    position: absolute;
    border: 2px solid #444444;
    border-radius: 5px;
    background-color: #ffffff;
    box-shadow: rgba(0,0,0,0.2) 3px 3px;
    padding: 3px;
    font-size: 10pt;
    text-align: center;
    vertical-align: middle;
}

.gocircle {
    position: absolute;
    font-family: 'Material Symbols Outlined';
    border: 2px solid #666666;
    border-radius: 50%;
    background-color: #ffffff;
    box-shadow: rgba(0,0,0,0.2) 3px 3px;
    font-size: 10pt;
}

.godistance {
    position: absolute;
    border: 2px solid #FFFFFF;
    background-color: #666666;
    color: #ffffff;
    border-radius: 5px;
    box-shadow: rgba(0,0,0,0.2) 3px 3px;
    padding: 3px;
    text-align: center;
    font-size: 10pt;
}

.gofree {
    position: absolute;
    top: 5px;
    left: 5px;
    background-color: #ffffff;
    padding: 3px;
}
/* end goverlay.css */
    </style>
    <script type='text/javascript'>
        // initialise.js
'use strict';
let map;
let minimalStyle;
// minimalstyle.js
minimalStyle = [{
        featureType: "landscape",
        elementType: "all",
        stylers: [{
            visibility: "off"
        }]
    },
    {
        featureType: "poi",
        elementType: "all",
        stylers: [{
            visibility: "off"
        }]
    },
    {
        featureType: "road",
        elementType: "all",
        stylers: [{
            visibility: "off"
        }]
    },
    {
        featureType: "transit",
        elementType: "all",
        stylers: [{
            visibility: "off"
        }]
    },
    {
        featureType: "landscape",
        elementType: "geometry",
        stylers: [{
            hue: "#ff0066"
        },
        {
            saturation: -100
        },
        {
            lightness: 100
        },
        {
            gamma: 0.07
        },
        {
            visibility: "on"
        }]
    },
    {
        featureType: "water",
        elementType: "all",
        stylers: [{
            saturation: 0
        },
        {
            lightness: 50
        },
        {
            visibility: "simplified"
        }]
    },
    {
        featureType: "administrative.province",
        elementType: "all",
        stylers: [{
            visibility: "off"
        }]
    },
    {
        featureType: "administrative.country",
        elementType: "geometry",
        stylers: [{
            hue: "#ff7000"
        },
        {
            lightness: 50
        },
        {
            saturation: 100
        }]
    },
    {
        featureType: "administrative",
        elementType: "labels",
        stylers: [{
            lightness: 40
        }]
}];
// minimalstyle.js
let mapOptions;
let initialisers = [];
var apikey = '0';
var libraries = 'geometry';
var startlat = 42;
var startlong = 19;
var startzoom = 4;
var mapstyle = 'roadmap';
var language = 'en';
var region = 'us';


// dynamic library import

  (g=>{var h,a,k,p="The Google Maps JavaScript API",c="google",l="importLibrary",q="__ib__",m=document,b=window;b=b[c]||(b[c]={});var d=b.maps||(b.maps={}),r=new Set,e=new URLSearchParams,u=()=>h||(h=new Promise(async(f,n)=>{await (a=m.createElement("script"));e.set("libraries",[...r]+"");for(k in g)e.set(k.replace(/[A-Z]/g,t=>"_"+t[0].toLowerCase()),g[k]);e.set("callback",c+".maps."+q);a.src=`https://maps.${c}apis.com/maps/api/js?`+e;d[q]=f;a.onerror=()=>h=n(Error(p+" could not load."));a.nonce=m.querySelector("script[nonce]")?.nonce||"";m.head.append(a)}));d[l]?console.warn(p+" only loads once. Ignoring:",g):d[l]=(f,...n)=>r.add(f)&&u().then(()=>d[l](f,...n))})({
    key: apikey,
    v: "weekly",
    language: language,
    region: region,
    libraries: 'geometry'
  });

function addInitialiser(f) {
    initialisers = initialisers.concat(f);
};

async function initMap() {
    // Are we connected to the Internet ?
    if (typeof google === "undefined") { 
        let text = '<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">' +
            '<html><head><title>No Internet connection</title></head>' +
            '<body>Looks like you are not connected to the Internet!</body></html>';
        let encodedText = encodeURIComponent(text);
        document.location.href = "javascript:(function(){document.open();document.write('" + encodedText + "');document.close();})();";
        return;
    };

    const { Map } = await google.maps.importLibrary("maps");
    map = new google.maps.Map(document.getElementById('map'), {});


    let minimalMapOptions = { name: "minimal" };
    let minimalMapType = new google.maps.StyledMapType(minimalStyle, minimalMapOptions);
    map.mapTypes.set('minimal', minimalMapType);

    mapOptions = {

        zoom: startzoom,
        center: (new google.maps.LatLng(startlat, startlong)),

        draggableCursor: 'crosshair',
        draggingCursor: 'move',

        disableDefaultUI: true,

        panControl: false,
        streetViewControl: false,
        zoomControl: false,
        scaleControl: false,
        navigationControl: false,
        mapTypeControl: false,

        scaleControlOptions: {
            position: google.maps.ControlPosition.BOTTOM_LEFT
        },

        navigationControlOptions: {
            style: google.maps.NavigationControlStyle.ZOOM_PAN,
            position: google.maps.ControlPosition.TOP_LEFT
        },

        mapTypeId: mapstyle,
        mapTypeControlOptions: {
            mapTypeIds: [
                google.maps.MapTypeId.hybrid,
                google.maps.MapTypeId.roadmap,
                google.maps.MapTypeId.satellite,
                google.maps.MapTypeId.terrain,
                'minimal'
            ]
        }
    };
    initialisers.forEach(function (q) {
        q()
    });
    map.setOptions(mapOptions);
}; // initMap
// end initialise.js
        // geodesix.js
'use strict';
addInitialiser(initialiseGeodesix);

let myInfoWindow;
let totaldistance;
let clickMarker = null;
let query = "";
let geocoder = null;
let matchlines = null;
let shadow = null;
let clickIcon = null;
let matchmarkers = null;
let midpoints = null;
let infowindow = null;
let overlays = []; // things he's drawn on this page
let MAPFILES_URL = "https://maps.gstatic.com/intl/en_us/mapfiles/";
let ICONFILES_URL = "https://maps.google.com/mapfiles/ms/icons/";

function addOverlay(id, obj, title, latlng) {

    overlays[id] = obj;
    
    if (title) {
    
        obj.set('title', title)

        if (obj.constructor.name == 'goverlay') {
            const div = obj.div;
            google.maps.event.addListener(obj, 'mouseover',
                function (obj) {
                    let content = '<div class="info">' + this.title + '</div>';
                    let iwo = {
                        content: content,
                        position: this.latlng
                    };
                    myInfoWindow.setOptions(iwo);
                    myInfoWindow.open(map);
                }
            );
        } else {
            google.maps.event.addListener(obj, 'mouseover',
                function (obj) {
                    let content = '<div class="info">' + this.title + '</div>';
                    let iwo = {
                        content: content,
                        position: this.latlng
                    };
                    myInfoWindow.setOptions(iwo);
                    myInfoWindow.open(map);
                }
            );
        }
    };
    obj.set('latlng', latlng);
    zoomToContent();
}
function bearing(a, b) {
    // Given 2 LatLng points, compute bearing in degress
    let lat1 = a.lat() * Math.PI / 180;
    let lng1 = a.lng() * Math.PI / 180;
    let lat2 = b.lat() * Math.PI / 180;
    let lng2 = b.lng() * Math.PI / 180;
    let dLon = lng2 - lng1;
    let y = Math.sin(dLon) * Math.cos(lat2);
    let x = Math.cos(lat1) * Math.sin(lat2) -
        Math.sin(lat1) * Math.cos(lat2) * Math.cos(dLon);
    let brng = Math.atan2(y, x) * 180 / Math.PI;
    if (brng < 0) {
        brng = brng + 360;
    }
    return brng;
}
function changeZoom(amount) {

    let myzoom = map.getZoom();
    myzoom = parseInt(myzoom) + parseInt(amount);
    setZoom(myzoom);
}
function clickedRightOnMap(event) {
    let latlonvalue = event.latLng.toUrlValue(7); // 7 = 1.11 cm precision
    sendMessage("rightclick", latlonvalue.toString());
}
function closeInfoWindow() {
    myInfoWindow.close();
};

// https://stackoverflow.com/a/2637079/338101
Number.prototype.toRad = function () {
    return this * Math.PI / 180;
}

Number.prototype.toDeg = function () {
    return this * 180 / Math.PI;
}

function destinationPoint(center, bearing, distance) {
    // 0=Northwards, 90=Eastwards
    distance = distance / 6371000;
    bearing = bearing.toRad();

    let lat1 = center.lat().toRad(), lon1 = center.lng().toRad();

    let lat2 = Math.asin(Math.sin(lat1) * Math.cos(distance) +
        Math.cos(lat1) * Math.sin(distance) * Math.cos(bearing));

    let lon2 = lon1 + Math.atan2(Math.sin(bearing) * Math.sin(distance) *
        Math.cos(lat1),
        Math.cos(distance) - Math.sin(lat1) *
        Math.sin(lat2));

    if (isNaN(lat2) || isNaN(lon2)) return null;

    return new google.maps.LatLng(lat2.toDeg(), lon2.toDeg());
}
function drawArrow(id, orig, dest, arrow, scale, strokeColor, strokeWeight, fillColor, fillOpacity) {

    const heading = google.maps.geometry.spherical.computeHeading(orig, dest);
    const centre = latlngCentre(orig.lat(), orig.lng(), dest.lat(), dest.lng());
    const directionMarker = new google.maps.Marker({
        position: centre,
        map: map,
        icon: {
            url: arrow,
            scale: scale,
            strokeColor: strokeColor,
            strokeWeight: strokeWeight,
            fillColor: fillColor,
            fillOpacity: fillOpacity,
            rotation: heading
        }
    });
    directionMarker.set('ne', orig);
    directionMarker.set('sw', dest);
    addOverlay(id, directionMarker, '', pos);
}
function drawCircle(id, lat, lng, radius, content, strokeColor, strokeOpacity, strokeWeight, fillColor, fillOpacity) {
    let center = new google.maps.LatLng(lat, lng);
    let circle = new google.maps.Circle({
        center: center,
        map: map,
        radius: radius,
        strokeColor: strokeColor,
        strokeOpacity: strokeOpacity,
        strokeWeight: strokeWeight,
        fillColor: fillColor,
        fillOpacity: fillOpacity
    });
    let ne = destinationPoint(center, -45, radius * 1.414);
    circle.set('ne', ne)
    let sw = destinationPoint(center, 135, radius * 1.414);
    circle.set('sw', sw)
    addOverlay(id, circle, content, center);

}
//function drawDirections(id, jsonpoints, mode, strokeColor, strokeOpacity, strokeWeight, suppressInfoWindows, suppressMarkers) {

//    let points = eval(jsonpoints);
//    let origin = new google.maps.LatLng(points[0], points[1]);
//    let destination = new google.maps.LatLng(points[points.length - 2], points[points.length - 1]);
//    let waypoints = [];
//    let path = [];
//    let j = 0;

//    for (let i = 2; i < points.length - 1; i += 2) {
//        let wp = new Object(); // a google.maps.DirectionsWaypoint()
//        let point = new google.maps.LatLng(points[i], points[i + 1]);
//        wp.location = point;
//        expandBounds(point);
//        wp.stopover = true;
//        waypoints[j] = wp;
//        j++;
//    }
//    let polylineOptions = {
//        strokeColor: strokeColor,
//        strokeOpacity: strokeOpacity,
//        strokeWeight: strokeWeight
//    };
//    let renderOptions = {
//        suppressInfoWindows: suppressInfoWindows,
//        suppressMarkers: suppressMarkers,
//        polylineOptions: polylineOptions
//    };
//    let dr = new google.maps.DirectionsRenderer(renderOptions);
//    dr.origin = origin;
//    dr.destination = destination;
//    dr.waypoints = waypoints;
//    dr.travelMode = google.maps.DirectionsTravelMode[mode];
//    let ds = new google.maps.DirectionsService();
//    let request = {
//        origin: origin,
//        destination: destination,
//        waypoints: waypoints,
//        travelMode: google.maps.DirectionsTravelMode[mode.toUpperCase()]
//    };

//    totaldistance = -1;

//    ds.route(request, function (response, status) {
//        if (status === google.maps.DirectionsStatus.OK) {
//            dr.setDirections(response);
//            dr.setMap(map);
//            // get distance
//            let directions = dr.getDirections();
//            let routes = directions.routes[0];
//            let legs = routes.legs;
//            let distance = 0;
//            for (i in legs) {
//                let legdistance = legs[i].distance;
//                if (typeof legdistance !== "undefined")
//                    if (typeof legdistance.value !== "undefined")
//                        distance = distance + legdistance.value;
//            }
//            totaldistance = distance;
//        }
//        else {
//            totaldistance = 0;
//            alert(status);
//        }
//    });
//    addOverlay(id, dr, null);
//}
//function drawInfoWindow(id, lat, lng, content) {

//    let poly = new google.maps.InfoWindow({
//        content: content,
//        map: map,
//        position: new google.maps.LatLng(lat, lng)
//    });
//    addOverlay(id, poly, null);
//}
//function drawLegend(id, html, quadrant) {

//    let name = 'geodesix' + id.toString();
//    let div = document.createElement('div');
//    div.style.backgroundColor = 'transparent';
//    div.setAttribute('id', name);
//    div.style.padding = '0px';
//    div.style.fontFamily = 'Arial,sans-serif';
//    div.innerHTML = html;
//    div.index = 1;
//    map.controls[google.maps.ControlPosition[quadrant.toUpperCase()]].push(div);
//}
function drawLine(id, lat1, lon1, lat2, lon2, title, strokeColor, strokeOpacity, strokeWeight) {
    let jsonpoints = [lat1, lon1, lat2, lon2];
    drawPolyLine(id, jsonpoints, title, strokeColor, strokeOpacity, strokeWeight)
}
function drawMarker(id, lat, lng, icon, title, size) {

    let marker = dropMarker(lat, lng, icon, title, size);
    addOverlay(id, marker, title, marker.position);
}
function drawPolygon(id, jsonpoints, title, strokeColor, strokeOpacity, strokeWeight, fillColor, fillOpacity) {

    let points = eval(jsonpoints);
    let paths = new google.maps.MVCArray;
    let bounds = new google.maps.LatLngBounds();
    for (let i = 0; i < points.length; i += 2) {
        let point = new google.maps.LatLng(points[i], points[i + 1]);
        bounds.extend(point);
        paths.push(point);
    }

    let poly = new google.maps.Polygon({
        path: paths,
        map: map,
        geodesic: true,
        strokeColor: strokeColor,
        strokeOpacity: strokeOpacity,
        strokeWeight: strokeWeight,
        fillColor: fillColor,
        fillOpacity: fillOpacity
    });
    poly.set('ne', bounds.getNorthEast());
    poly.set('sw', bounds.getSouthWest());
    addOverlay(id, poly, title, bounds.getCenter());
}
function drawPolyLine(id, jsonpoints, title, strokeColor, strokeOpacity, strokeWeight) {

    let points = eval(jsonpoints);
    let path = new google.maps.MVCArray;
    let bounds = new google.maps.LatLngBounds();
    let j = 0;
    for (let i = 0; i < points.length; i += 2) {
        let point = new google.maps.LatLng(points[i], points[i + 1]);
        bounds.extend(point);
        path.push(point);
    };
    let poly = new google.maps.Polyline({
        path: path,
        map: map,
        strokeColor: strokeColor,
        strokeOpacity: strokeOpacity,
        strokeWeight: strokeWeight
    });
    poly.set('ne', bounds.getNorthEast());
    poly.set('sw', bounds.getSouthWest());
    addOverlay(id, poly, title, bounds.getCenter());
}
function dropMarker(lat, lng, icon, title, size) {

    let theicon = icon;
    if (icon.substring(0, 1) === "{")
        theicon = eval('theicon = ' + theicon);
    let marker = new google.maps.Marker({
        icon: {
            url: theicon,
            scaledSize: new google.maps.Size(size, size)
        },
        map: map,
        position: new google.maps.LatLng(lat, lng),
        title: title,
        visible: true
    });
    return marker;
}
function expandBounds(latlng) {
    if (latlng) {
        let bounds = map.getBounds();
        if (bounds) {
            if (bounds.contains(latlng)) {
                return;
            } else {
                bounds.extend(latlng);
                map.fitBounds(bounds);
            }
        }
    }
}
function geocode(request) {
    if (request.latlng) {
        clickMarker = new google.maps.Marker({
            'position': request.latlng,
            'map': map,
            'title': request.latlng.toString(),
            'clickable': false,
            'icon': new google.maps.MarkerImage(
                ICONFILES_URL + 'red-pushpin.png'
            )
        });
        map.panTo(latlng);
        setZoom(16);
    } else {
        geocoder.geocode(request, showResults);
    }
}
function getMarkerImageUrl(resultNum) {

    // Get a numbered maker from Google, A, B, C, etc.
    // https://maps.gstatic.com/intl/en_us/mapfiles/markerA.png etc
    return MAPFILES_URL + "marker" + String.fromCharCode(65 + resultNum) + ".png";
}
function getResultDescription(result) {
    let bounds = result.geometry.bounds;
    let html = '<table class="tabContent">';
    html += trs(unBracket(result.formatted_address));
    html += '</table>';
    return html;
}
function getResultsListItem(resultNum, resultDescription) {

    // Make a pretty, clickable HTML description of a result
    let html = '<a onclick="gotoMarker(' + resultNum + ')">';
    html += '<div class="info" id="p' + resultNum + '">';
    html += '<table><tr valign="top">';
    html += '<td style="padding: 2px"><img src="' + getMarkerImageUrl(resultNum) + '"/></td>';
    html += '<td style="padding: 2px">' + resultDescription + '</td>';
    html += '</tr></table>';
    html += '</div></a>';
    return html;
}
function gotoMarker(resultNum) {

    // When he clicks on a result marker, take him to the place

    let position = matchmarkers[resultNum].position;
    let title = matchmarkers[resultNum].title;
    let bounds = matchmarkers[resultNum].bounds;
    resetMap();
    clickMarker = new google.maps.Marker({
        'position': position,
        'map': map,
        'title': title,
        'clickable': false,
        'icon': clickIcon,
        'shadow': shadow
    });
    map.panTo(position);
}
function haversine(pos1, pos2) {
    // Compute the Haversine distance between two places.
    // I know that Vincenty's algorithm is more accurate, but unnecessary here and a fuck-sight faster
    let R = 6371; // km
    let lat1r = toRadians(pos1.lat());
    let lon1r = toRadians(pos1.lng());
    let lat2r = toRadians(pos2.lat());
    let lon2r = toRadians(pos2.lng());
    let d = Math.acos(Math.sin(lat1r) * Math.sin(lat2r) + Math.cos(lat1r) * Math.cos(lat2r) * Math.cos(lon2r - lon1r)) * R;
    return d;
}
function initialiseGeodesix() {

    parseUrlParams();

    geocoder = new google.maps.Geocoder();

    myInfoWindow = new google.maps.InfoWindow({});
    google.maps.event.addListener(map, 'rightclick', clickedRightOnMap);
    google.maps.event.addListener(map, 'zoom_changed', zoomChanged);

    if (query) {
        submitQuery(query);
    };
}
function latlngCentre(lat1, lng1, lat2, lng2) {
    // LatLngBounds has getCenter but it's sensitive to NE/SW
    return new google.maps.LatLng((lat1 + lat2) / 2, (lng1 + lng2) / 2);
}
function latlngToScreen(latlng) {

    let numTiles = 1 << map.getZoom();
    let projection = map.getProjection();
    let worldCoordinate = projection.fromLatLngToPoint(latlng);
    let pixelCoordinate = new google.maps.Point(
        worldCoordinate.x * numTiles,
        worldCoordinate.y * numTiles);

    let topLeft = new google.maps.LatLng(
        map.getBounds().getNorthEast().lat(),
        map.getBounds().getSouthWest().lng()
    );

    let topLeftWorldCoordinate = projection.fromLatLngToPoint(topLeft);
    let topLeftPixelCoordinate = new google.maps.Point(
        topLeftWorldCoordinate.x * numTiles,
        topLeftWorldCoordinate.y * numTiles);

    return {
        x: pixelCoordinate.x - topLeftPixelCoordinate.x,
        y: pixelCoordinate.y - topLeftPixelCoordinate.y
    }
}
function loadScript(file) {
    let script = document.createElement("script");
    script.type = "title/javascript";
    script.src = file;
    document.body.appendChild(script);
};
function overlay(id, onoff) {

    let result = "";
    let obj = overlays[id];

    if (typeof obj === "undefined") {
        alert('Layer object ' + id.toString + ' is not defined');
        return;
    }

    switch (onoff.toLowerCase()) {

        case 'true':
            obj.setMap(map);
            result = 'true';
            break;

        case 'false':
            obj.setMap(null);
            result = 'false';
            break;

        default:
            if (obj.getMap() === null)
                result = 'false';
            else
                result = 'true';
            break;
    }
    return result;
}
function parseUrlParams() {

    if (window.location.search) {
        let args = decodeURIComponent(window.location.search).substring(1).split('&');
        for (let i in args) {
            let param = args[i].split('=');
            switch (param[0].toLowerCase()) {
                case 'api':
                    api = param[1];
                    break;
                case 'key':
                    apikey = param[1];
                    break;
                case 'q':
                    query = param[1];
                    break;
                case 'center':
                    let center = parseLatLng(param[1]);
                    if (center !== null) {
                        startlat = center.lat();
                        startlon = center.lng();
                    }
                    break;
                case 'zoom':
                    let zoom = parseInt(param[1]);
                    if (!isNaN(zoom)) {
                        startzoom = zoom;
                    }
                    break;
                case 'region':
                    region = param[1];
                    break;
                case 'language':
                    language = param[1];
                    break;
                case 'version':
                    version = param[1];
                    break;
                case 'mapstyle':
                    mapstyle = param[1].toLowerCase();
                    break;
            }
        }
    }
}
function parseLatLng(value) {
    value.replace('/\s//g');
    let coords = value.split(',');
    let lat = parseFloat(coords[0]);
    let lng = parseFloat(coords[1]);
    if (isNaN(lat) || isNaN(lng)) {
        return null;
    } else {
        return new google.maps.LatLng(lat, lng);
    }
}
function plotMatchesOnMap(results) {

    matchmarkers = new Array(results.length);
    let resultsListHtml = "";

    // Create a handler to select one of the results when he clicks it
    let hitselector = function (mm) {
        return function () {
            selectHit(mm);
        };
    };

    if (results.length === 0) {
        alert(NOTHINGFOUND);
    }

    if (results.length > 1) {
        for (let i = 0; i < results.length; i++) {

            // We know as a fact the Google's marker images (like )
            // are 20 wide by 34 high
            let icon = new google.maps.MarkerImage(getMarkerImageUrl(i), // URL
                new google.maps.Size(20, 34), // True size
                new google.maps.Point(0, 0), // origin
                new google.maps.Point(10, 34)); // anchor

            matchmarkers[i] = new google.maps.Marker({
                'position': results[i].geometry.location,
                'map': map,
                'icon': icon,
                'shadow': shadow,
                'title': results[i].formatted_address,
                bounds: results[i].geometry.bounds
            });

            google.maps.event.addListener(matchmarkers[i], 'click', hitselector(i));

            resultsListHtml += getResultsListItem(i, getResultDescription(results[i]));
        }
        // Display the matches in a nice little box where he can select one
        document.getElementById("matches").innerHTML = resultsListHtml;
        document.getElementById("p0").style.border = "none";
        document.getElementById("matches").style.display = "none";
    }

    // Now, according to the number of results, display on the map too
    if (results.length > 0) { // OK, there were some
        if (results.length === 1) { // There was exactly one result
            let location = results[0].geometry.location.toString();
            let latlong = location;
            latlong.replace('/\s//g');
            latlong = unBracket(latlong);
            let coords = latlong.split(',');
            let lat = parseFloat(coords[0]).toString();
            let lng = parseFloat(coords[1]).toString();
            // Make a nicely decorated marker
            clickMarker = new google.maps.Marker({
                'position': results[0].geometry.location,
                'map': map,
                'title': results[0].formatted_address,
                'clickable': false,
                'icon': clickIcon,
                'shadow': shadow
            });
            map.panTo(results[0].geometry.location);
            setZoom(15);
        } else {
            // Many results, show them all in the viewport and let him choose one
            document.getElementById("matches").style.display = "block";
            zoomToViewports(results);
        }
    }
}
function resetMap() {
    myInfoWindow.close();
    if (clickMarker !== null) {
        clickMarker.setMap(null);
        clickMarker = null;
    }
    for (let i in matchmarkers) {
        matchmarkers[i].setMap(null);
    }
    matchmarkers = [];
    for (let j in matchlines) {
        matchlines[j].setMap(null);
    }
    matchlines = [];

    document.getElementById("matches").innerHTML = "";
    document.getElementById("matches").style.display = "none";
}
function sendMessage(command, data) {
    let wv = window.chrome.webview;
    if (wv) {
        let json = { 'command': command, 'data': data };
        window.chrome.webview.postMessage(json);
    }
}
function setCenter(lat, lng) {
    let center = new google.maps.LatLng(lat, lng);
    map.setCenter(center);
}
function setZoom(zoom) {
    map.setZoom(zoom);
    zoomChanged();
}
function selectHit(mm) {
    gotoMarker(mm);
}
function setMapStyle(style) {
    let mapstyle = style;
    map.setMapTypeId(mapstyle);
}
function showResults(results, status) {

    if (status === google.maps.GeocoderStatus.OK) {
        plotMatchesOnMap(results);
    } else {
        alert(String(status));
    }
}
function showRoute(origin, destination, mode) {

    let directionsRenderer;
    let directionsService = new google.maps.DirectionsService();
    // draw lines in red, easier to see
    let polylineOptions = {
        strokeColor: '#FF0000'
    };
    let renderOptions = {
        polylineOptions: polylineOptions
    };
    //directionsDisplay = new google.maps.DirectionsRenderer(renderOptions);
    directionsRenderer = new google.maps.DirectionsRenderer({
        preserveViewport: true,
        suppressMarkers: true
    });
    directionsRenderer.setMap(map);
    let request = {
        origin: { query: origin },
        destination: { query: destination },
        travelMode: mode.toUpperCase()
    };
    directionsService.route(request, function (response, status) {
        if (status == google.maps.DirectionsStatus.OK) {
            directionsRenderer.setDirections(response);
            map.fitBounds(response.routes[0].bounds);
        }
        else
            alert(status);
    });
}
function submitQuery(query) {
    resetMap();
    if (query !== "") {
        let latlng = parseLatLng(query);
        if (latlng === null) {
            geocode({
                'address': query
            });
        } else {
            clickMarker = new google.maps.Marker({
                'position': latlng,
                'map': map,
                'title': "",
                'clickable': false,
                'icon': new google.maps.MarkerImage(
                    ICONFILES_URL + 'red-pushpin.png'
                )
            });
            map.panTo(latlng);
            setZoom(12);
        }
    }
}
function toRadians(a) {
    return a * (Math.PI / 180);
}
function tr(key, value) {
    return '<tr>' + '<td class="key">' + key + (key ? ':' : '') + '</td>' + '<td class="value">' + value + '</td>' + '</tr>';
}
function trs(value) {
    return '<tr>' + '<td class="key"></td>' + '<td class="value">' + value + '</td>' + '</tr>';
}
function unBracket(s) {
    // Remove parenthses from start/end of a string
    let a;
    a = s;
    if (a.substring(0, 1) === '(') a = a.substring(1);
    if (a.substring(a.length - 1, 1) === ')') a = a.substring(0, a.length - 2);
    return a;
}
function zoomChanged() {
    sendMessage("zoomChanged", map.getZoom());
}
function zoomToContent() {

    let fit = 0;
    let bounds = new google.maps.LatLngBounds();
    for (let i = 0; i < overlays.length; i++) {
        let obj = overlays[i];
        if (obj) {
            let ne = obj.get('ne');
            let sw = obj.get('sw');
            if (ne && sw) {
                bounds.extend(ne);
                bounds.extend(sw);
                fit += 2;
            } else {
                let latlng = obj.get('latlng');
                if (latlng) {
                    bounds.extend(latlng);
                    fit += 1;
                };
            }
        }
    };
    if (fit < 2) { // Only one object, don't do sily zoom=22
        let centre = bounds.getCenter();
        map.panTo(centre);
        map.setZoom(16);
    } else {
        map.fitBounds(bounds);
    }
}
function zoomToViewports(results) {

    // For a given set of results, zoom the viewport so that they are all visible
    let bounds = new google.maps.LatLngBounds();

    for (let i = 0; i < results.length; i++) {
        bounds.union(results[i].geometry.viewport);
    }
}
// end geodesix.js
        let task = initMap();
        task.then((result) => {
            /* drawDecorations */
function drawDecorations() {
/*  goverlay.js */
class goverlay extends google.maps.OverlayView {

    id;
    type;
    latlng;
    icon;
    title;
    size;
    color;
    align;
    angle;
    symbols;

    div;
    span;
    fixed;

    constructor(id, type, latlng, icon, title, size, color, align, angle, symbols) {
        super();
        this.id = id;
        this.type = type;
        this.latlng = latlng;
        this.icon = icon;
        this.title = title;
        this.size = size;
        this.color = color;
        this.align = align;
        this.angle = angle;
        if (symbols) 
            this.symbols = symbols
        else
            this.symbols = 'outlined';
        this.fixed = false;

        this.div = document.createElement('div');
        this.div.className = 'go'+this.type; 

        switch (this.type) {

            case 'arrow': // Arrows
                this.fixed = true;
                this.span = document.createElement('span');
                this.div.appendChild(this.span);
                this.span.className = 'material-symbols-outlined';
                this.span.style.fontSize = this.size + 'px';
                this.span.innerHTML = this.icon;
                if (this.angle != 0)
                    // 1px is a hack to get rotatated material symbols to align correctly
                    this.span.style.transform = 'rotate('+this.angle+'deg) translate(1px)'
                break;

            case 'box': // text in a box
                this.div.innerHTML = this.icon;
                break;

            case 'circle': // material icon in a circle
                this.fixed = true;
                this.div.style.fontSize = this.size + 'px';
                this.div.innerHTML = this.icon;
                this.div.classList.add("material-symbols-outlined");
                const padding = 5;
                this.div.style.padding = padding + 'px';
                // increase size from icon size to circle size
                this.size = this.size * 2 + padding;
                break;

            case 'distance': // CSS .goverlay .distance will look after formatting
                this.div.innerHTML = this.icon;
                break;

            case 'free': // Replace div with a Span
                this.div.innerHTML = this.icon;
                break;

            case 'marker':
                const marker = dropMarker(this.latlng.lat(), this.latlng.lng(), icon, title, size)
                this.div.appendChild(marker);
                break;

        };
        if (this.color)
            this.div.style.color = this.color;

        //console.log('create '+this.type+' @ '+this.latlng.lat+','+this.latlng.lng+
        //    ' cw='+this.div.clientWidth+' ch='+this.div.clientHeight+
        //    ' w=2'+this.div.style.width+' h='+this.div.style.height);


    }

    // onAdd is called when the map's panes are ready and the overlay has been added to the map.
    onAdd() {

        // Add the element to the "overlayLayer" pane.
        const panes = this.getPanes();

        panes.overlayMouseTarget.appendChild(this.div);

        // Hack for mousemove
        // https://stackoverflow.com/a/3402480/338101
        let me = this;
        google.maps.event.addDomListener(me.div, 'mouseover', function() {
            google.maps.event.trigger(me, 'mouseover');
        });
    }
    draw() {
        const overlayProjection = this.getProjection();
        const center = overlayProjection.fromLatLngToDivPixel(this.latlng);

        if (this.type == 'free') {
            return;
        }

        let height;
        let width;
        if (this.fixed) {
            height = this.size;
            width = this.size;
        } else {
            height = this.div.clientHeight;
            width = this.div.clientWidth;
        }
        let height2 = height / 2;
        let width2 = width / 2;

        let left = center.x - width2;
        let top = center.y - height2;

        //console.log('draw '+this.type+' @ '+this.latlng.lat+','+this.latlng.lng+
        //            ' l='+left+' top='+top+' w='+width+' h='+height);

        switch(this.align.toLowerCase().substring(0, 1)) {
            case 'b':
                top = top + height2 + 2;
                break;
            case 't':
                top = top - height2 - 2;
                break
            case 'l':
                left = left - width2 - 2;
                break
            case 'r':
                left = left + width2 + 2;
                break
        };

        this.div.style.left = left + "px";
        this.div.style.top = top + "px";
    }
    /**
     * The onRemove() method will be called automatically from the API if
     * we ever set the overlay's map property to 'null'.
     */
    onRemove() {
        if (this.div) {
            this.div.parentNode.removeChild(this.div);
            delete this.div;
        }
    }
    /**
     *  Set the visibility to 'hidden' or 'visible'.
     */
    hide() {
        if (this.div) {
            this.div.style.visibility = "hidden";
        }
    }
    show() {
        if (this.div) {
            this.div.style.visibility = "visible";
        }
    }
    toggle() {
        if (this.div) {
            if (this.div.style.visibility === "hidden") {
                this.show();
            } else {
                this.hide();
            }
        }
    }
    toggleDOM(map) {
        if (this.getMap()) {
            this.setMap(null);
        } else {
            this.setMap(map);
        }
    }
}

function drawGoverlay(id, type, latlng, icon, title, size, color, align, angle, symbols) {
    let mi = new goverlay(id, type, latlng, icon, title, size, color, align, angle, symbols);
    mi.setMap(map);
    addOverlay(id, mi, title, latlng);
    return mi
};
/*  end goverlay.js */
drawLine(
            81,
            34.9861005,135.7593909, 
            34.682341,135.8201532, 
            '',
            'Red',
            1,
            3);
drawLine(
            85,
            34.682341,135.8201532, 
            36.5639118,136.653995, 
            '',
            'Red',
            1,
            3);
drawLine(
            89,
            36.5639118,136.653995, 
            34.6959812,135.4999638, 
            '',
            'Red',
            1,
            3);
drawLine(
            93,
            34.6959812,135.4999638, 
            33.5853875,130.3998772, 
            '',
            'Red',
            1,
            3);
drawLine(
            97,
            33.5853875,130.3998772, 
            34.38913,132.463326, 
            '',
            'Red',
            1,
            3);
drawLine(
            101,
            34.38913,132.463326, 
            34.6661818,133.9177391, 
            '',
            'Red',
            1,
            3);
drawLine(
            105,
            34.6661818,133.9177391, 
            34.3248037,134.1796663, 
            '',
            'Red',
            1,
            3);
drawLine(
            109,
            34.3248037,134.1796663, 
            34.1183293,134.3888603, 
            '',
            'Red',
            1,
            3);
drawLine(
            113,
            34.1183293,134.3888603, 
            34.0915761,134.5842278, 
            '',
            'Red',
            1,
            3);
drawLine(
            117,
            34.0915761,134.5842278, 
            33.8565931,134.01922, 
            '',
            'Red',
            1,
            3);
drawLine(
            121,
            33.8565931,134.01922, 
            33.921252,133.8176793, 
            '',
            'Red',
            1,
            3);
drawLine(
            125,
            33.921252,133.8176793, 
            34.2252865,133.774483, 
            '',
            'Red',
            1,
            3);
drawLine(
            129,
            34.2252865,133.774483, 
            34.4453573,133.9906555, 
            '',
            'Red',
            1,
            3);
drawLine(
            133,
            34.4453573,133.9906555, 
            34.5767819,133.8253838, 
            '',
            'Red',
            1,
            3);
drawLine(
            137,
            34.5767819,133.8253838, 
            35.1697296,136.8813642, 
            '',
            'Red',
            1,
            3);
drawLine(
            141,
            35.1697296,136.8813642, 
            35.2040425,139.0327613, 
            '',
            'Red',
            1,
            3);
drawLine(
            145,
            35.2040425,139.0327613, 
            35.2433944,139.0537379, 
            '',
            'Red',
            1,
            3);
drawLine(
            149,
            35.2433944,139.0537379, 
            35.6091523,139.7491939, 
            '',
            'Red',
            1,
            3);
drawLine(
            153,
            35.6091523,139.7491939, 
            35.5448424,139.7693082, 
            '',
            'Red',
            1,
            3);
drawGoverlay(
            83,
            'arrow',
            {lat:34.9252525034045,lng:135.771599129871}, 
            'Expand_Less',
            '',
            36,
            'red',
            'center',
            170.616860907055,
            'outlined'
        );
drawGoverlay(
            87,
            'arrow',
            {lat:35.0595794958721,lng:135.984014539761}, 
            'Expand_Less',
            '',
            36,
            'red',
            'center',
            19.6501905376998,
            'outlined'
        );
drawGoverlay(
            91,
            'arrow',
            {lat:36.190994230463,lng:136.418674510903}, 
            'Expand_Less',
            '',
            36,
            'red',
            'center',
            -152.896041131151,
            'outlined'
        );
drawGoverlay(
            95,
            'arrow',
            {lat:34.4914567808772,lng:134.471898620296}, 
            'Expand_Less',
            '',
            36,
            'red',
            'center',
            -103.2343868144,
            'outlined'
        );
drawGoverlay(
            99,
            'arrow',
            {lat:33.7485917715966,lng:130.808685159588}, 
            'Expand_Less',
            '',
            36,
            'red',
            'center',
            64.3648791917649,
            'outlined'
        );
drawGoverlay(
            103,
            'arrow',
            {lat:34.4457823460415,lng:132.752702985912}, 
            'Expand_Less',
            '',
            36,
            'red',
            'center',
            76.6266779296809,
            'outlined'
        );
drawGoverlay(
            107,
            'arrow',
            {lat:34.5979181294153,lng:133.970322289301}, 
            'Expand_Less',
            '',
            36,
            'red',
            'center',
            147.499929493556,
            'outlined'
        );
drawGoverlay(
            111,
            'arrow',
            {lat:34.2835396314631,lng:134.221585153082}, 
            'Expand_Less',
            '',
            36,
            'red',
            'center',
            139.856478167313,
            'outlined'
        );
drawGoverlay(
            115,
            'arrow',
            {lat:34.1130174193894,lng:134.427841828932}, 
            'Expand_Less',
            '',
            36,
            'red',
            'center',
            99.2934529369185,
            'outlined'
        );
drawGoverlay(
            119,
            'arrow',
            {lat:34.0448721535352,lng:134.471180741808}, 
            'Expand_Less',
            '',
            36,
            'red',
            'center',
            -116.369904410019,
            'outlined'
        );
drawGoverlay(
            123,
            'arrow',
            {lat:33.8695238816643,lng:133.979021476391}, 
            'Expand_Less',
            '',
            36,
            'red',
            'center',
            -68.9025336664173,
            'outlined'
        );
drawGoverlay(
            127,
            'arrow',
            {lat:33.982172175361,lng:133.809048969775}, 
            'Expand_Less',
            '',
            36,
            'red',
            'center',
            -6.73066566949074,
            'outlined'
        );
drawGoverlay(
            131,
            'arrow',
            {lat:34.2693325503501,lng:133.817628029866}, 
            'Expand_Less',
            '',
            36,
            'red',
            'center',
            39.1139883211758,
            'outlined'
        );
drawGoverlay(
            135,
            'arrow',
            {lat:34.4716456976447,lng:133.95766100887}, 
            'Expand_Less',
            '',
            36,
            'red',
            'center',
            -46.1033618515028,
            'outlined'
        );
drawGoverlay(
            139,
            'arrow',
            {lat:34.7011874935895,lng:134.431496244879}, 
            'Expand_Less',
            '',
            36,
            'red',
            'center',
            75.8813162967746,
            'outlined'
        );
drawGoverlay(
            143,
            'arrow',
            {lat:35.1796235593244,lng:137.310285197035}, 
            'Expand_Less',
            '',
            36,
            'red',
            'center',
            88.2672419834423,
            'outlined'
        );
drawGoverlay(
            147,
            'arrow',
            {lat:35.211920890399,lng:139.036959102889}, 
            'Expand_Less',
            '',
            36,
            'red',
            'center',
            23.6190850653597,
            'outlined'
        );
drawGoverlay(
            151,
            'arrow',
            {lat:35.3167578782452,lng:139.192119547474}, 
            'Expand_Less',
            '',
            36,
            'red',
            'center',
            57.0763935654868,
            'outlined'
        );
drawGoverlay(
            155,
            'arrow',
            {lat:35.5962730674699,lng:139.753224833532}, 
            'Expand_Less',
            '',
            36,
            'red',
            'center',
            165.660522678842,
            'outlined'
        );
drawGoverlay(
            82,
            'distance',
            {lat:34.83422075,lng:135.78977205}, 
            '34 Km',
            '',
            0,
            '',
            'center',
            0,
            ''
        );
drawGoverlay(
            86,
            'distance',
            {lat:35.6231264,lng:136.2370741}, 
            '222 Km',
            '',
            0,
            '',
            'center',
            0,
            ''
        );
drawGoverlay(
            90,
            'distance',
            {lat:35.6299465,lng:136.0769794}, 
            '232 Km',
            '',
            0,
            '',
            'center',
            0,
            ''
        );
drawGoverlay(
            94,
            'distance',
            {lat:34.14068435,lng:132.9499205}, 
            '486 Km',
            '',
            0,
            '',
            'center',
            0,
            ''
        );
drawGoverlay(
            98,
            'distance',
            {lat:33.98725875,lng:131.4316016}, 
            '210 Km',
            '',
            0,
            '',
            'center',
            0,
            ''
        );
drawGoverlay(
            102,
            'distance',
            {lat:34.5276559,lng:133.19053255}, 
            '137 Km',
            '',
            0,
            '',
            'center',
            0,
            ''
        );
drawGoverlay(
            106,
            'distance',
            {lat:34.49549275,lng:134.0487027}, 
            '45 Km',
            '',
            0,
            '',
            'center',
            0,
            ''
        );
drawGoverlay(
            110,
            'distance',
            {lat:34.2215665,lng:134.2842633}, 
            '30 Km',
            '',
            0,
            '',
            'center',
            0,
            ''
        );
drawGoverlay(
            114,
            'distance',
            {lat:34.1049527,lng:134.48654405}, 
            '18 Km',
            '',
            0,
            '',
            'center',
            0,
            ''
        );
drawGoverlay(
            118,
            'distance',
            {lat:33.9740846,lng:134.3017239}, 
            '58 Km',
            '',
            0,
            '',
            'center',
            0,
            ''
        );
drawGoverlay(
            122,
            'distance',
            {lat:33.88892255,lng:133.91844965}, 
            '20 Km',
            '',
            0,
            '',
            'center',
            0,
            ''
        );
drawGoverlay(
            126,
            'distance',
            {lat:34.07326925,lng:133.79608115}, 
            '34 Km',
            '',
            0,
            '',
            'center',
            0,
            ''
        );
drawGoverlay(
            130,
            'distance',
            {lat:34.3353219,lng:133.88256925}, 
            '31 Km',
            '',
            0,
            '',
            'center',
            0,
            ''
        );
drawGoverlay(
            134,
            'distance',
            {lat:34.5110696,lng:133.90801965}, 
            '21 Km',
            '',
            0,
            '',
            'center',
            0,
            ''
        );
drawGoverlay(
            138,
            'distance',
            {lat:34.87325575,lng:135.353374}, 
            '287 Km',
            '',
            0,
            '',
            'center',
            0,
            ''
        );
drawGoverlay(
            142,
            'distance',
            {lat:35.18688605,lng:137.95706275}, 
            '196 Km',
            '',
            0,
            '',
            'center',
            0,
            ''
        );
drawGoverlay(
            146,
            'distance',
            {lat:35.22371845,lng:139.0432496}, 
            '5 Km',
            '',
            0,
            '',
            'center',
            0,
            ''
        );
drawGoverlay(
            150,
            'distance',
            {lat:35.42627335,lng:139.4014659}, 
            '75 Km',
            '',
            0,
            '',
            'center',
            0,
            ''
        );
drawGoverlay(
            154,
            'distance',
            {lat:35.57699735,lng:139.75925105}, 
            '7 Km',
            '',
            0,
            '',
            'center',
            0,
            ''
        );
drawGoverlay(
                    80,
                    'box',
                    {lat:34.9861005,lng:135.7593909}, 
                    'Kyoto Station',
                    'Nov 3 日本、〒600-8216<br />京都府京都市下京区東塩小路釜殿町',
                    24,
                    'blue',
                    'Centre',
                    0,
                    'outlined'
                );
drawGoverlay(
                    84,
                    'box',
                    {lat:34.682341,lng:135.8201532}, 
                    'Onyado Nono Nara',
                    'Nov 3 日本、〒630-8115<br />奈良県奈良市大宮町１丁目１−６',
                    24,
                    'blue',
                    'Centre',
                    0,
                    'outlined'
                );
drawGoverlay(
                    88,
                    'box',
                    {lat:36.5639118,lng:136.653995}, 
                    'KOKO HOTEL<br />Premier 金沢香林坊',
                    'Nov 6 日本、〒920-0961<br />石川県金沢市香林坊１丁目２−１６',
                    24,
                    'blue',
                    'Centre',
                    0,
                    'outlined'
                );
drawGoverlay(
                    92,
                    'box',
                    {lat:34.6959812,lng:135.4999638}, 
                    'The Rise Osaka<br />Kitashinchi',
                    'Nov 7 日本、〒530-0003<br />大阪府大阪市北区堂島１丁目１−１３',
                    24,
                    'blue',
                    'Centre',
                    0,
                    'outlined'
                );
drawGoverlay(
                    96,
                    'box',
                    {lat:33.5853875,lng:130.3998772}, 
                    'Imaizumi Park',
                    'Nov 9 日本、〒810-0021<br />福岡県福岡市中央区今泉１丁目８',
                    24,
                    'blue',
                    'Centre',
                    0,
                    'outlined'
                );
drawGoverlay(
                    100,
                    'box',
                    {lat:34.38913,lng:132.463326}, 
                    'Smile Hotel<br />Hiroshima',
                    'Nov 10 日本、〒730-0028<br />広島県広島市中区流川町７−１０',
                    24,
                    'blue',
                    'Centre',
                    0,
                    'outlined'
                );
drawGoverlay(
                    104,
                    'box',
                    {lat:34.6661818,lng:133.9177391}, 
                    'Okayama Station',
                    'Nov 12 日本、〒700-0024<br />岡山県岡山市北区駅元町１−１',
                    24,
                    'blue',
                    'Centre',
                    0,
                    'outlined'
                );
drawGoverlay(
                    108,
                    'box',
                    {lat:34.3248037,lng:134.1796663}, 
                    'Shidoji Temple',
                    'Nov 12 日本、〒769-2101<br />香川県さぬき市志度１１０２',
                    24,
                    'blue',
                    'Centre',
                    0,
                    'outlined'
                );
drawGoverlay(
                    112,
                    'box',
                    {lat:34.1183293,lng:134.3888603}, 
                    'Anrakuji Temple',
                    'Nov 12 日本、〒771-1311<br />徳島県板野郡上板町引野寺ノ西北８',
                    24,
                    'blue',
                    'Centre',
                    0,
                    'outlined'
                );
drawGoverlay(
                    116,
                    'box',
                    {lat:34.0915761,lng:134.5842278}, 
                    'Tokushima Puppet<br />Theater and Museum',
                    'Nov 13 日本、〒771-0114<br />徳島県徳島市川内町宮島本浦１８４',
                    24,
                    'blue',
                    'Centre',
                    0,
                    'outlined'
                );
drawGoverlay(
                    120,
                    'box',
                    {lat:33.8565931,lng:134.01922}, 
                    'Nagoro "Scarecrow"<br />Village',
                    'Nov 14 日本、〒778-0201<br />徳島県三好市東祖谷菅生629番地5',
                    24,
                    'blue',
                    'Centre',
                    0,
                    'outlined'
                );
drawGoverlay(
                    124,
                    'box',
                    {lat:33.921252,lng:133.8176793}, 
                    'Statue of<br />a Peeing<br />Boy',
                    'Nov 14 日本、〒778-0165<br />徳島県三好市池田町松尾松本',
                    24,
                    'blue',
                    'Centre',
                    0,
                    'outlined'
                );
drawGoverlay(
                    128,
                    'box',
                    {lat:34.2252865,lng:133.774483}, 
                    '熊岡菓子店',
                    'Nov 16 日本、〒765-0003<br />香川県善通寺市善通寺町３丁目４−１１',
                    24,
                    'blue',
                    'Centre',
                    0,
                    'outlined'
                );
drawGoverlay(
                    132,
                    'box',
                    {lat:34.4453573,lng:133.9906555}, 
                    'Benesse<br />House Museum',
                    'Nov 19 日本、〒761-3110<br />香川県香川郡直島町 琴弾地',
                    24,
                    'blue',
                    'Centre',
                    0,
                    'outlined'
                );
drawGoverlay(
                    136,
                    'box',
                    {lat:34.5767819,lng:133.8253838}, 
                    'Chayamachi Station',
                    'Nov 20 日本、〒710-1101<br />岡山県倉敷市茶屋町 倉敷市茶屋町４７８',
                    24,
                    'blue',
                    'Centre',
                    0,
                    'outlined'
                );
drawGoverlay(
                    140,
                    'box',
                    {lat:35.1697296,lng:136.8813642}, 
                    'Nagoya Station',
                    'Nov 20 日本、〒450-0002<br />愛知県名古屋市中村区名駅１丁目１−４',
                    24,
                    'blue',
                    'Centre',
                    0,
                    'outlined'
                );
drawGoverlay(
                    144,
                    'box',
                    {lat:35.2040425,lng:139.0327613}, 
                    'RoheN Resort&Lounge<br />HAKONE',
                    'Nov 20 日本、〒250-0522<br />神奈川県足柄下郡箱根町元箱根１０６',
                    24,
                    'blue',
                    'Centre',
                    0,
                    'outlined'
                );
drawGoverlay(
                    148,
                    'box',
                    {lat:35.2433944,lng:139.0537379}, 
                    'The Hakone<br />Open-Air Museum',
                    'Nov 21 日本、〒250-0407<br />神奈川県足柄下郡箱根町二ノ平１１２１',
                    24,
                    'blue',
                    'Centre',
                    0,
                    'outlined'
                );
drawGoverlay(
                    152,
                    'box',
                    {lat:35.6091523,lng:139.7491939}, 
                    'Shinagawa<br />Seaside<br />Station',
                    'Nov 22 日本、〒140-0002<br />東京都品川区東品川４丁目１２−２２',
                    24,
                    'blue',
                    'Centre',
                    0,
                    'outlined'
                );
drawGoverlay(
                    156,
                    'box',
                    {lat:35.5448424,lng:139.7693082}, 
                    'Haneda Airport',
                    'Nov 24 日本、〒144-0041<br />東京都大田区羽田空港',
                    24,
                    'blue',
                    'Centre',
                    0,
                    'outlined'
                );
}; /* end drawDecorations */
drawDecorations();
zoomToContent();

        });
    </script>
</head>
<body>
    <div id="map"></div>
    <div id="matches"></div>
    <noscript>Javascript disabled. Maps cannot be displayed.</noscript>
    
</body>
</html> <!-- end base.html -->
